### Day 2 – STL 컨테이너 성능 비교 & Move Semantics 분석

#### 1. Vector vs List – 시간 복잡도(O 표기)
| 연산 | vector | list | 차이 원인 |
|------|--------|------|----------|
| **push_back** | **O(1)** (amortized) | **O(1)** | vector: capacity 초과 시 O(n) 재할당 발생<br>list: tail 포인터 연결만 수행 |
| **랜덤 위치 삽입** | **O(n)** | **O(n)** | vector: 연속 메모리 복사<br>list: 탐색 O(n) + 연결 O(1) |
| **삭제(랜덤 위치)** | **O(n)** | **O(n)** | vector: 빈자리에 데이터 당겨와야함<br>list: 탐색 O(n) |
| **인덱스 접근** | **O(1)** | **O(n)** | vector: 포인터 + 인덱스 연산<br>list: 순차 탐색 |

> - 삽입/삭제가 드물고 순차 접근 많으면 vector
> - 임베디드 환경에서는 cache locality 때문에 vector 선호도 높음

#### 2. push_back vs emplace_back
| 연산 방식 | 시간 복잡도 | 차이 원인 |
|-----------|------------|-----------|
| `push_back(T obj)` | O(1) (생성+복사/이동) | 이미 생성된 객체를 복사/이동 |
| `emplace_back(args...)` | O(1) (직접 생성) | 컨테이너 내부에서 in-place 생성 → 불필요한 복사 없음 |

> - emplace_back은 복잡한 객체에 효과적
> - POD 타입에서는 성능 차이 거의 없음

#### 3. Copy vs Move Semantics
| 연산 방식 | 시간 복잡도 | 차이 원인 |
|-----------|------------|-----------|
| Copy Constructor | O(n) | 모든 멤버 깊은 복사 |
| Move Constructor | O(1) | 내부 포인터 소유권 이전만 수행 |

> - 대량 데이터 구조에서는 move로 복사 최소화 → 성능 향상
> - 메모리 제한이 있는 Qualcomm 임베디드 환경에서 특히 중요

#### 4. 캐시 로컬리티(Cache Locality) 관점
- vector: 연속 메모리 → CPU 캐시에 효율적 로드 → 순차 접근 속도 ↑
- list: 노드가 메모리 여기저기 분산 → 캐시 미스 발생률 ↑
- 삽입/삭제가 많아도 list가 항상 빠르지 않음


#### emplace_back v.s. push_back 테스트가 성공할 때도 있고 실패할 때도 있었음
원인
- 워밍업/캐시 상태: 첫 실행은 콜드 캐시, 이후는 핫 캐시
- 메모리 할당 변동: reserve() 안하면 재할당 타이밍이 매번 달라짐
- 랜덤 삽입: 매번 다른 위치 -> 작업량이 달라짐
- 컴파일러 최적화: 복사/이동 경로가 최적화로 지워짐 (RVO/NRVO 등)

다음과 같은 방법으로 문제 해결 시도
- 측정 전 reserve 하여 재할당 노이즈 제거
- 고정 시드 사용: std::mt19937 rng(12345)
- median 사용하여 중앙값 사용
- steady_clock 사용 + 충분한 작업량

cold-start latency: 프로그램/기능을 처음 실행할 때의 지연(캐시,TLB,페이지 미탑재 포함)
steady-state throughput: 한 번 워밍업 된 뒤 반복 수행 시의 평균 성능

콜드 캐시를 고려하여 다음과 같은 측정 방법 추가
1. 측정 목표 분리
- cold: 캐시/페이지를 최대한 비운 뒤 첫 1회만 기록
- warm: 같은 작업을 5~10회 반복하여 median 기록
2. 유저 권한으로 안전하게 콜드 상태 만들기
- LLC(라스트레벨 캐시)보다 큰 버퍼를 만들어 전 범위를 읽어드림 -> 캐시를 오염시킴 (**Thrash**)
3. 시스템 변수 고정
- CPU 고정: taskset -c -0 ./bench
- 전원/스케일링 고정: 성능모드, 터보 끄거나 고정
- 빌드: -02 고정, 동일 바이너릴로만 비교
4. I/O는 분리
- 현재 테스트는 CPU/메모리 바운드라 디크스 I/O 영향 제거(파일 쓰기 금지)

nth_elemnet (c++ 17부터 사용가능)
- 정렬보다 빠르게 특정 위치의 원소를 정렬된 상태로 찾아줌

7회 반복: 홀수 & 적당한 반복 횟수, 이외에 큰 의미는 없음

##### LLC (Last Level Cache)
- CPU안에 있는 여러 단계의 캐시(L1, L2, ...) 중 마지막 단계의 캐시
- 구조
    - L1: 가장 빠르고 용량 작음(수십 KB, 명령/데이터 분리)
    - L2: L1보다 느리고 용량 큼(수백 KB ~ 수 MB, 명령/데이터 통합)
    - L3/L4 (LLC): 여러 코어가 공유
- LLC는 메인 메모리(DRAM)에 접근하기 전 마지막 속도 방어선
    - LLC 히트 -> 메모리보다 훨씬 빠름 (수십 ns vs 수백 ns)
    - LLC 미스 -> DRAM 접근 (느림)

#### Thrash(캐시 쓰래싱) 동작 원리
의도: 캐시 안에 들어있는 데이터를 의도적으로 채워 캐시를 쓰레기 값으로 채워넣고 측정하려는 코드가 cold cache 환경에서 실행되게 만드는 것

동작 방식:
    - CPU 캐시는 주소 기반으로 데이터를 블록 단위로 관리한다
        - Cache line: 보통 64B
        - LLC 전체 용량이 예를들어 8MB라면 -> 8MB / 64B = 131072 라인
    - 캐시 쓰래싱은 이 용량을 초과하는 데이터를 순차적으로 읽어서 모든 라인을 덮어쓰게 한다
    - 예를 들어, LLC가 8MB인 경우, 16MB짜리 버퍼를 64B씩 stride로 읽으면 기존 캐시라인이 다 날아감

**쉽게 말해 64바이트 단위로 256MN(default로 지정해둠)을 훑으면 32MB(현재 내 컴퓨터 LLC 캐시 용량)을 넘는 시점부터 교체 발생**

> - LLC 용량 확인하기
    `cat /sys/devices/system/cpu/cpu0/cache/index3/size`
    => 현재 내 컴퓨터의 용량은 32768K로 나타남. 32M라 보면 될듯

#### optimize-away 방지
테스트 코드에 보면 다음과 같은 라인이 있다.
```cpp
uint64_t sum = 0;
for (size_t i = 0; i < buf.size(); i += 64) sum += buf[i];
// 여기서 sum을 사용하는 곳이 없어 컴파일러가 이 루프 자체를 없앨 수도 있다

// 다음과 같은 트릭을 이용하여 해결
// 빈 어셈블리를 삽입하지만, 입력 오퍼랜드로 sum을 사용한다고 선언
// volatile이라 컴파일러가 이 블록을 없애거나 재정렬하지 못함
asm volatile("" :: "r"(sum));
```

#### 기존 테스트 코드가 in-place의 이점을 못살리고 있어 3가지 케이스로 분류함. 큰 차이가 없어 용량을 늘렸음에도 실패함
- 매 반복마다 tmp를 만들 때 data(size,100)로 채움(fill) 작업을 한다
- push_back(tmp)(=복사)는 tmp를 한 번 fill + memcpy -> 아주 빠름
- emplace_back("...", size)는 목적지에서 직접 fill(복사는 없지만 채우는 루프가 필요)
- push_back(std::move(tmp))는 tmp에서 목적지로 포인터만 옮기기라 그 자체는 싸지만 어차피 tmp를 생성할 때 fill 했음

즉, 지금의 비교는 대략 다음과 같음
    copy: fill + memcpy
    move: fill
    emplace: fill
환경에 따라 memcpy가 매우 최적화되어 있어 fill 한 번보다 빠르게 나올 수 있다
그래서 copy < move/emplace 처럼 보였을 수 있음 (특히 int 10000개는 rep movsq 같은 경로로 잘 터짐)

보다 명확한 비교를 위해 다음과 같은 방법을 사용해본다
- 현재 구조처럼 매 반복마다 임시로 만들고 삽입을 하되, copy/move/emplace 가 가은 초기화 비용을 치르도록 정의한다
- 예를들어 BigObject를 비싼 생성자 없는 타입으로 정의하고 데이터를 생성 후 채우지 않으면 copy만 비싸질 것이다

-> 이렇게 하면 move/emplcae가 확실히 유리해보임